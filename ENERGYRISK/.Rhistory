#set up tree characteristics for the preliminary tree.
discount <- exp(-tree_Params$r*tree_Params$delta_t)
level_x = -c(-tree_Params$delta_x*((6):1),tree_Params$delta_x*(0:(6))) #trinomial tree prices at time N/2. Symmetric about 0.
j.index = seq(from=0, to=6, by=1) #month number, 0 to 6 by 1's
nbNodes = seq(from=1,to=length(level_x),by=2) #number of nodes at each time point
mult = 1
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("Option Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
i = 1
i = 5
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
prob
j
tree_Params$delta_t
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
prob
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
library(ENERGYRISK)
source("./R/Lattices.R")
data(S4_Params)
tree_Params <- list("alpha" = 0.338, "delta_t" = 0.8333333, "delta_x" = 0.152702,
"S0" = 21.05, "K" = 21, "maturity" = 1, "r" = 0.06, "volatility" = 0.305404)
a_is <- t(data.frame(c(3.046901, 3.041576, 3.034532, 3.027756, 3.021138, 3.014664, 3.008326)))
colnames(a_is) <- c("X0", "X1", "X2", "X3", "X4", "X5", "X6")
rownames(a_is) <- "a_i"
prob <- function(j, delta_t, alpha, delta_x, vol){
i=0
pu =  c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 - (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pd = c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 + (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
#set up tree characteristics for the preliminary tree.
discount <- exp(-tree_Params$r*tree_Params$delta_t)
level_x = -c(-tree_Params$delta_x*((6):1),tree_Params$delta_x*(0:(6))) #trinomial tree prices at time N/2. Symmetric about 0.
j.index = seq(from=0, to=6, by=1) #month number, 0 to 6 by 1's
nbNodes = seq(from=1,to=length(level_x),by=2) #number of nodes at each time point
mult = 1
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("Option Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
i.index
i = 5
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
prob
j
tree_Params$delta_t
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo4_code.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
library(ENERGYRISK)
library(ENERGYRISK)
library(lubridate)
library(zoo)
source('~/.active-rstudio-document')
S6_ForwardCurve
S6_ModelParams
S6_ForwardCurve
S6_ForwardCurve$Date
S6_ForwardCurve$Date[1]
S6_ForwardCurve$Date[length(S6_ForwardCurve)]-S6_ForwardCurve$Date[1]
class(S6_ForwardCurve$Date)
as.numeric(S6_ForwardCurve$Date[length(S6_ForwardCurve)]-S6_ForwardCurve$Date[1])
S6_ForwardCurve
nbDays = as.numeric(S6_ForwardCurve[length(S6_ForwardCurve[,1]),1]-
S6_ForwardCurve[1,1])
nbDays
S6_ForwardCurve$Date[nrow(S6_ForwardCurve)]
S6_ForwardCurve$Date[nrow(S6_ForwardCurve)]-S6_ForwardCurve$Date[1]
storDates = as.Date(x = S6_ForwardCurve$Date[1]:S6_ForwardCurve$Date[nrow(S6_ForwardCurve)])
storDates
valStart = storDates[1]; valEnd = storDates[length(storDates)]
valStart
valEnd
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
param
source('~/.active-rstudio-document')
valueStor
valueStor[1,c("Power","Gas")] = c(S6_ForwardCurve$Power[1], S6_ForwardCurve$Gas[1])
View(valueStor)
dt = storDates[2]-storDates[1]
dt
dt = 1/storDates[length(storDates)]-storDates[1]
dt = 1/(as.numeric(storDates[length(storDates)]-storDates[1]))
dt
dt == 1/365
storDates
S6_ForwardCurve$Date
format(S6_ForwardCurve$Date, "%m/%y")
storDates[2]
i = 1
S6_ForwardCurve[trackMonth,"Power"]
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[i+1],"%m%y"))
trackMonth
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[6+1],"%m%y"))
trackMonth
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[60+1],"%m%y"))
trackMonth
S6_ForwardCurve[trackMonth,"Power"]
S6_ForwardCurve[trackMonth+1,"Power"]
i
i/nbDays
rand1 = qnorm(runif(1,min=0,max=1))
rand2 = qnorm(runif(1,min=0,max=1))
rand1
qnorm?
?qnorm
qnorm(3, 0, 1)
qnorm(3, 0, 1)
qnorm(1, 0, 1)
qnorm(.99, 0, 1)
qnorm(.96, 0, 1)
qnorm(-1, 0, 1)
qnorm(0, 0, 1)
qnorm(0.00000001, 0, 1)
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
valueStor
S6_ForwardCurve
it
i
for(i in 1:(nbDays-1)){   #each simulation simulates 364 days
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[i+1],"%m%y")) #keep track of month
#get current month and next month's forward prices
F_t1 = c(S6_ForwardCurve[trackMonth,"Power"],S6_ForwardCurve[trackMonth,"Gas"])
F_t2 = c(S6_ForwardCurve[trackMonth+1,"Power"],S6_ForwardCurve[trackMonth+1,"Gas"])
t1 = i/nbDays
#standard normal random variables... get number between 0 and 1 and find value giving that quantile from normal dist.
rand1 = qnorm(runif(1,min=0,max=1)) #epsilon 1
rand2 = qnorm(runif(1,min=0,max=1)) #epsilon 2
dz1 = sqrt(dt)*rand1
# stochastic gas component which is correlated to power demand
dz2 = S6_ModelParams$rho[1]*dz1 + sqrt(1-(S6_ModelParams$rho[1])^2)*sqrt(dt)*rand2
# Estimate mu from mean-reverting model and forward prices?
muPower = (1/S6_ModelParams[1,"alpha"])*
(log(F_t2[1])-log(F_t1[1]))/(1/12) +
log(F_t1[1]) + S6_ModelParams[1,"sigma"]^2 /
(4*S6_ModelParams[1,"alpha"] ) *(1 - exp(-2*S6_ModelParams[1,"alpha"]*t1))
muGas = (1/S6_ModelParams[2,"alpha"])*
(log(F_t2[2])-log(F_t1[2]))/(1/12) +
log(F_t1[2]) + S6_ModelParams[2,"sigma"]^2 /
(4*S6_ModelParams[2,"alpha"] ) *(1 - exp(-2*S6_ModelParams[2,"alpha"]*t1))
# delta_x = (alpha(mu-x) - .5*sigma^2)*dt - sigma*sqrt(t)*epsilon
tempPower = log(valueStor[i,"Power"]) + (S6_ModelParams[1,"alpha"]*
(muPower-log(valueStor[i,"Power"])) -
0.5 * S6_ModelParams[1,"sigma"]^2) * dt + S6_ModelParams[1,"sigma"]* dz1
tempGas = log(valueStor[i,"Gas"]) + (S6_ModelParams[2,"alpha"]*
(muGas-log(valueStor[i,"Gas"])) -
0.5 * S6_ModelParams[2,"sigma"]^2) * dt + S6_ModelParams[2,"sigma"]* dz2
valueStor[i+1,"Power"] = exp(tempPower)
valueStor[i+1,"Gas"] = exp(tempGas)
# Option value payoff for plant: df*max(0, P-HR*G-K)
valueStor[i+1,"CT"] = max(0,valueStor[i+1,"Power"]-param$heatRate*valueStor[i+1,"Gas"]-
param$K)*
exp(-param$r*(as.numeric(storDates[i]-valDate)/365))#discount_factor
}
valDate = storDates[1]; valEnd = storDates[length(storDates)] #valuation dates
for(i in 1:(nbDays-1)){   #each simulation simulates 364 days
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[i+1],"%m%y")) #keep track of month
#get current month and next month's forward prices
F_t1 = c(S6_ForwardCurve[trackMonth,"Power"],S6_ForwardCurve[trackMonth,"Gas"])
F_t2 = c(S6_ForwardCurve[trackMonth+1,"Power"],S6_ForwardCurve[trackMonth+1,"Gas"])
t1 = i/nbDays
#standard normal random variables... get number between 0 and 1 and find value giving that quantile from normal dist.
rand1 = qnorm(runif(1,min=0,max=1)) #epsilon 1
rand2 = qnorm(runif(1,min=0,max=1)) #epsilon 2
dz1 = sqrt(dt)*rand1
# stochastic gas component which is correlated to power demand
dz2 = S6_ModelParams$rho[1]*dz1 + sqrt(1-(S6_ModelParams$rho[1])^2)*sqrt(dt)*rand2
# Estimate mu from mean-reverting model and forward prices?
muPower = (1/S6_ModelParams[1,"alpha"])*
(log(F_t2[1])-log(F_t1[1]))/(1/12) +
log(F_t1[1]) + S6_ModelParams[1,"sigma"]^2 /
(4*S6_ModelParams[1,"alpha"] ) *(1 - exp(-2*S6_ModelParams[1,"alpha"]*t1))
muGas = (1/S6_ModelParams[2,"alpha"])*
(log(F_t2[2])-log(F_t1[2]))/(1/12) +
log(F_t1[2]) + S6_ModelParams[2,"sigma"]^2 /
(4*S6_ModelParams[2,"alpha"] ) *(1 - exp(-2*S6_ModelParams[2,"alpha"]*t1))
# delta_x = (alpha(mu-x) - .5*sigma^2)*dt - sigma*sqrt(t)*epsilon
tempPower = log(valueStor[i,"Power"]) + (S6_ModelParams[1,"alpha"]*
(muPower-log(valueStor[i,"Power"])) -
0.5 * S6_ModelParams[1,"sigma"]^2) * dt + S6_ModelParams[1,"sigma"]* dz1
tempGas = log(valueStor[i,"Gas"]) + (S6_ModelParams[2,"alpha"]*
(muGas-log(valueStor[i,"Gas"])) -
0.5 * S6_ModelParams[2,"sigma"]^2) * dt + S6_ModelParams[2,"sigma"]* dz2
valueStor[i+1,"Power"] = exp(tempPower)
valueStor[i+1,"Gas"] = exp(tempGas)
# Option value payoff for plant: df*max(0, P-HR*G-K)
valueStor[i+1,"CT"] = max(0,valueStor[i+1,"Power"]-param$heatRate*valueStor[i+1,"Gas"]-
param$K)*
exp(-param$r*(as.numeric(storDates[i]-valDate)/365))#discount_factor
}
valueStor
sum(valueStor[,3])
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
simStor
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
se = sd(simStor[,"Thermal_valuation"])/sqrt(param$M)
se
mean(simStor[,"Thermal_valuation"])
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
se = sd(simStor[,"Thermal_valuation"])/sqrt(param$M) #standard error in MC valuation
thermal_val = mean(simStor[,"Thermal_valuation"])
result = data.frame(t(c(thermal_val, se)))
colnames(result) = c("Call_value", "std_error")
rownames(result) = "Result"
result
avgOptionValue = matrix(0, param$M, 1)
for (kk in 1:param$M){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
head(simStor)
avgOptionValue = matrix(0, param$M, 1)
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
avgOptionValue
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
S6_ForwardCurve
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8,
main = "Monte Carlo Convergence of Option Value") #we haven't implemented antithetic valuation method.
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value")
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value")
title("Monte Carlo Convergence of Option Value", cex = .8)
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value", cex = .8)
title("Monte Carlo Convergence of Option Value", cex.main = .8)
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value", cex.main = .8)
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
#Distribution of MC payoffs
hist(simMatrix[,2],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStore[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 20)
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 200)
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 20)
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
abline(h = result$Call_value, col = "red")
source('~/.active-rstudio-document')
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
abline(h = result$Call_value, col = "red")
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
### CFRM 520 HW2. Frank Fineis.
library(ENERGYRISK)
source("./R/Lattices.R")
data(S4_Params)
tree_Params <- list("alpha" = 0.338, "delta_t" = 0.08333333, "delta_x" = 0.152702,
"S0" = 21.05, "K" = 21, "maturity" = 1, "r" = 0.06, "volatility" = 0.305404)
a_is <- t(data.frame(c(3.046901, 3.041576, 3.034532, 3.027756, 3.021138, 3.014664, 3.008326)))
colnames(a_is) <- c("X0", "X1", "X2", "X3", "X4", "X5", "X6")
rownames(a_is) <- "a_i"
#set up tree characteristics for the preliminary tree.
discount <- exp(-tree_Params$r*tree_Params$delta_t)
level_x = -c(-tree_Params$delta_x*((6):1),tree_Params$delta_x*(0:(6))) #trinomial tree prices at time N/2. Symmetric about 0.
j.index = seq(from=0, to=6, by=1) #month number, 0 to 6 by 1's
nbNodes = seq(from=1,to=length(level_x),by=2) #number of nodes at each time point
##### Value EUROPEAN PUT Option ####
mult = -1 #put option...
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("European Put Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Primary difference between EUROPEAN and AMERICAN Options
# Update the V vector of option values at each time step and node
V = pmax(0, discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("European Put Values:\n")
print(V)
offset = offset +1
}
##### Value AMERICAN CALL Option ####
mult = 1 #call, not put. Put is valued at K-S.
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
any(Forw<16)
any(Forw>30)
KOed = which(Forw>30 | Forw<16)
Koed
KOed
tree_Params$K
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
KOed = which(Forw>30 | Forw<16)
Forw[KOed] <- 0
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
##### Value AMERICAN PUT Double Barrier Knock-out Option ####
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
KOed = which(Forw<barrier[1] | Forw>barrier[2])
Forw[KOed] <- 0
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
KOed = which(Forw<barrier[1] | Forw>barrier[2])
Forw[KOed] <- 0
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# Print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
##### Value AMERICAN CALL Option ####
mult = 1 #call, not put. Put is valued at K-S.
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
