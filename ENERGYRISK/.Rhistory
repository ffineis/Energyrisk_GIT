# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
KOed = which(Forw<barrier[1] | Forw>barrier[2])
Forw[KOed] <- 0
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# Print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
##### Value AMERICAN CALL Option ####
mult = 1 #call, not put. Put is valued at K-S.
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
library(ENERGYRISK)
24*365
source('~/.active-rstudio-document')
data(data_S7)
View(`S7_ModelParams`)
S7_ModelParams
head(S7_ModelParams)
source('~/.active-rstudio-document')
valDate
class(valDate)
storDates = as.Date(valDate:valEnd)
library(lubridate)
library(zoo)
data(data_S7)
#get model parameters to project Power and rainfall evolution
head(S7_ModelParams)
N = 100 # number of simulations
valDate = as.Date("01/01/09", format = "%m/%d/%y")
valEnd = as.Date("03/31/09", format = "%m/%d/%y")
storDates = as.Date(valDate:valEnd)
class(storDates)
storWkday = as.POSIXlt(storDates, format = "%Y-%m-%d")
storWkday
nbDays = as.numeric(valEnd-valDate)
length(storDates)
Efficiency = 0.7222 # 72.22% of energy used to pump water up will be regained
F_Peak = 55; F_OPeak = 25; r = 0.05
param = list(Efficiency = Efficiency, F_Peak = F_Peak, F_OPeak = 25, r = r, N = N)
param
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
simMatrix = matrix(0, param$N, 2)
dt = 1/(365*2*24)
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
nb30min = nbDays*24*2 #number of 30-min intervals in day
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
simMatrix = matrix(0, param$N, 2)
dt = 1/(365*2*24)
rep(1:48, nb30min/48)
nb30min
storDates[1]
storDates[3]
storDates[2]
storWkday
storWkday[1]
storWkday[3]
storWkday[3]==3
storWkday[3]==2
storWkday[3]==1
storWkday[3]==4
storWkday[3]==5
storWkday[3]==6
storWkday[3]==7
storWkday = storWkday$wday
storWkday[3]==6
storWkday[3]==5
source("./R/ENERGYRISK.R")
source("./R/ES1_F.R")
S7_ModelParams$jFrequency
S7_ModelParams$jFrequency[1]
S7_ModelParams
S7_ModelParams$jFrequency[1]*dt
dt
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(TRUE)
as.numeric(FALSE)
S7_ModelParams$jFrequency[1]*dt
i - 3
i = 3
valueStor[,"Period"] = rep(1:48, nb30min/48)
valueStor[1,"Power"] = param$F_OPeak
F_t1 = param$F_OPeak ##### IMPORTANT ######
valueStor[1, "PumpGen"] = -1 #offpeak
offsetDate = 1
offset = -48 #index for new day
trackDate = 1
if(valueStor[i, "Period"] == 1){offset = offset+48} #indexing can't start at -48
if(storDates[offsetDate]=="2009-01-01"){muPower=param$F_OPeak}
else if(storWkday[trackDate]==6||storWkday[trackDate]==0){muPower=param$F_OPeak}
else if(valueStor[i,"Period"]>44||valueStor[i,"Period"]<15){muPower=param$F_OPeak}
else{muPower=param$F_Peak}
F_t2 = muPower
t1=i/(365*2*24)
rand1=randPolarRejc()
rand2=randPolarRejc()
dz1 = sqrt(dt)*rand1
dz2 = sqrt(dt)*rand2
#TRUE = 1, FALSE = 0
jFrequency = as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
#get mu from model:
muPower = (1/S7_ModelParams$alpha[1])*(log(F_t2)-log(F_t1))/dt + log(F_t1) + S7_ModelParams$sigma[1]^2/(4*S7_ModelParams$alpha[1])*(1-exp(-2*S7_ModelParams$alpha[1]*t1))
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
muPower
dz2
dz1
t1
muPower
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
head(valueStor)
i = 1
if(valueStor[i, "Period"] == 1){offset = offset+48} #indexing can't start at -48
if(storDates[offsetDate]=="2009-01-01"){muPower=param$F_OPeak}
else if(storWkday[trackDate]==6||storWkday[trackDate]==0){muPower=param$F_OPeak}
else if(valueStor[i,"Period"]>44||valueStor[i,"Period"]<15){muPower=param$F_OPeak}
else{muPower=param$F_Peak}
F_t2 = muPower
t1=i/(365*2*24)
rand1=randPolarRejc()
rand2=randPolarRejc()
dz1 = sqrt(dt)*rand1
dz2 = sqrt(dt)*rand2
#TRUE = 1, FALSE = 0
jFrequency = as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
#get mu from model:
muPower = (1/S7_ModelParams$alpha[1])*(log(F_t2)-log(F_t1))/dt + log(F_t1) + S7_ModelParams$sigma[1]^2/(4*S7_ModelParams$alpha[1])*(1-exp(-2*S7_ModelParams$alpha[1]*t1))
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
45*30
48*30
offset
jFrequency
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo4_code.R')
S4_Params
S4_Params
params = S4_Params[,"X0":"X3"]
params = S4_Params[,c(1:4)]
params
level_x = seq(from = -3, to = 0, by = -1)
level_x = seq(from = -3, to = 0, by = 1)
level_x
level_x = dx*seq(from = -3, to = 3, by = 1)
level_x = seq(from = -3, to = 3, by = 1)
level_x
level_x = dx*seq(from = -3, to = 3, by = 1)
S4_Params
S4_Params
1*exp(-0.06*dt)
1*exp(-0.06*dt)*exp(-0.06*dt)
1*exp(-0.06*dt)*exp(-0.06*dt)^2
1*exp(-0.06*dt)^4
dt = 0.083; dx = 0.153; r = params["R_ts",1]
r
df = exp(-r*dt)
df
Q_level3 = numeric(0)
Q_level3
source('~/.active-rstudio-document')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
as.data.frame(4)
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
chod = as.data.frame(4)
rownames(chod) = "chod"
chod
colnames(chod) = "boner"
chod
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
result1
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
result11
result1
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
result1
result2
result3
probs_level2 = prob(2, dt, alpha, dx, sigma)
probs_level2
prob <- function(j, delta_t, alpha, delta_x, vol){
i=0
pu =  c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 - (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pd = c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 + (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pm = 1 - pu - pd
prob = list(pu = pu,pm = pm,pd = pd)
return(prob)
}
probs_level2 = prob(2, dt, alpha, dx, sigma)
probs_level2$pd
Q_level3 = numeric(0, length = nbNodes)
#according to "State prices continued" slide
Q_level3 = numeric(length = nbNodes)
#according to "State prices continued" slide
Q_level3[0] = Q_level2[1]*probs_level2$pd*df
Q_level3[nbNodes] = Q_level3[0]
Q_level3
Q_level3 = numeric(length = nbNodes)
#according to "State prices continued" slide
Q_level3[1] = Q_level2[1]*probs_level2$pd*df
Q_level3[nbNodes] = Q_level3[1]
Q_level3
Q2
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
Q_2
Q_3[2] = Q_2[1]*probs_level2$pm*df + Q[2]*probs_level2$pd*df
Q_3[2] = Q_2[1]*probs_level2$pm*df + Q_2[2]*probs_level2$pd*df
df = exp(-r*dt)
probs_level2 = prob(2, dt, alpha, dx, sigma)
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
#Want Q_level3: will have 7 nodes.
Q_3 = numeric(length = nbNodes)
#according to "State prices continued" slide
Q_3[1] = Q_2[1]*probs_level2$pd*df
Q_3[nbNodes] = Q_3[1]
Q_3[2] = Q_2[1]*probs_level2$pm*df + Q_2[2]*probs_level2$pd*df
Q_3
for(jj in 3:5){print(jj)}
Q_3[2] = Q_2[1]*probs_level2$pm*df + Q_2[2]*probs_level2$pd*df
Q_3[nbNodes-1] = Q_3[2]
#fill in rest of level 3 state prices... ones that have 3 paths to each Q_i,j
for(jj in 3:5){
Q_3[jj] = Q_2[jj-2]*probs_level2$pu*df + Q_2[jj-1]*probs_level2$pm*df +
Q_2[jj]*probs_level2$pd*df
}
Q_3
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
#Want Q_level3: will have 7 nodes.
Q_3 = numeric(length = nbNodes)
#according to "State prices continued" slide
Q_3[1] = Q_2[1]*probs_level2$pd*df
Q_3[nbNodes] = Q_3[1]
Q_3[2] = Q_2[1]*probs_level2$pm*df + Q_2[2]*probs_level2$pd*df
Q_3[nbNodes-1] = Q_3[2]
Q_3
Q_3[1] = Q_2[1]*probs_level2$pd*df
Q_3[1]
df
df*0.252*0.1401
probs_level2$pu
dx
dt
sigma
alpha
probs_level2
prob <- function(j, delta_t, alpha, delta_x, vol){
i=0
pu =  c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 - (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pd = c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 + (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
prob <- function(i,j, delta_t, alpha, delta_x, vol){
pu =  c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 - (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pd = c(1/2*((vol^2*delta_t + alpha^2* j^2*delta_t^2)/
delta_x^2 + (i-i)^2 + (alpha* j*delta_t)/delta_x*
(1-2*(i-i)) - (i-i)))
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
probs_level3
prob <- function(x, dt, alpha, dx, vol){
pu =  1/2*((vol^2*dt + alpha^2*(x^2)*delta_t^2)/dx^2) -
((alpha*x*dt)/dx)
pd = 1/2*((vol^2*dt + alpha^2*(x^2)*delta_t^2)/dx^2) +
((alpha*x*dt)/dx)
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
level_x
level_x2 = dx*seq(from = -2, to = 2, by = 1)
level_x2
prob(level_x2[1], dt, alpha, dx, sigma)
prob <- function(x, dt, alpha, dx, vol){
pu =  1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) -
((alpha*x*dt)/dx)
pd = 1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) +
((alpha*x*dt)/dx)
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
prob(level_x2[1], dt, alpha, dx, sigma)
prob(level_x2[2], dt, alpha, dx, sigma)
prob(level_x2[3], dt, alpha, dx, sigma)
prob(level_x2[4], dt, alpha, dx, sigma)
prob(level_x2[5], dt, alpha, dx, sigma)
##### Problem 4: 3-level (indexing at 0) trinomial tree solution #####
#What do we need to fill out the 3rd level of the tree?
# simplified tree price levels
# Option values (i.e. discounted expected value of option values at theoretical j = 4 level)
# transition probabilities to go from level 3 to theoretical j = 4 level
# State prices at level 3.
params = S4_Params[,c(1:4)]
alpha = 0.338; sigma = 0.305
dt = 0.083; dx = 0.153; r = params["R_ts",1]
#simplified prices at level 3:
level_x3 = dx*seq(from = -3, to = 3, by = 1)
nbNodes = 7 #number of nodes at 3rd level
j = 3
#transition probabilities: From Thomas Fillebeen
prob <- function(x, dt, alpha, dx, vol){
pu =  1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) -
((alpha*x*dt)/dx)
pd = 1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) +
((alpha*x*dt)/dx)
pm = 1 - pu - pd
prob = t(cbind(pu,pm,pd))
return(prob)
}
# transition probs
level_x2 = dx*seq(from = -2, to = 2, by = 1)
probs_level3 = prob(3, dt, alpha, dx, sigma)
# Calculate a_3 so we can get option values at j = 3
df = exp(-r*dt)
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
#Want Q_level3: will have 7 nodes.
Q_3 = numeric(length = nbNodes)
#according to "State prices continued" slide
prob2_1 = prob(level_x2[1], dt, alpha, dx, sigma)
prob2_2 = prob(level_x2[2], dt, alpha, dx, sigma)
prob2_3 = prob(level_x2[3], dt, alpha, dx, sigma)
prob2_4 = prob(level_x2[4], dt, alpha, dx, sigma)
prob2_5 = prob(level_x2[5], dt, alpha, dx, sigma)
Q_3[1] = Q_2[1]*prob2_1$pd*df
prob <- function(x, dt, alpha, dx, vol){
pu =  1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) -
((alpha*x*dt)/dx)
pd = 1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) +
((alpha*x*dt)/dx)
pm = 1 - pu - pd
prob = list(pu = pu, pm = pm, pd = pd)
return(prob)
}
# transition probs
level_x2 = dx*seq(from = -2, to = 2, by = 1)
probs_level3 = prob(3, dt, alpha, dx, sigma)
# Calculate a_3 so we can get option values at j = 3
df = exp(-r*dt)
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
#Want Q_level3: will have 7 nodes.
Q_3 = numeric(length = nbNodes)
#according to "State prices continued" slide
prob2_1 = prob(level_x2[1], dt, alpha, dx, sigma)
prob2_2 = prob(level_x2[2], dt, alpha, dx, sigma)
prob2_3 = prob(level_x2[3], dt, alpha, dx, sigma)
prob2_4 = prob(level_x2[4], dt, alpha, dx, sigma)
prob2_5 = prob(level_x2[5], dt, alpha, dx, sigma)
Q_3[1] = Q_2[1]*prob2_1$pd*df
Q_3
##### Problem 4: 3-level (indexing at 0) trinomial tree solution #####
#What do we need to fill out the 3rd level of the tree?
# simplified tree price levels
# Option values (i.e. discounted expected value of option values at theoretical j = 4 level)
# transition probabilities to go from level 3 to theoretical j = 4 level
# State prices at level 3.
params = S4_Params[,c(1:4)]
alpha = 0.338; sigma = 0.305
dt = 0.083; dx = 0.153; r = params["R_ts",1]
#simplified prices at level 3:
level_x3 = dx*seq(from = -3, to = 3, by = 1)
nbNodes = 7 #number of nodes at 3rd level
j = 3
#transition probabilities: From Thomas Fillebeen
prob <- function(x, dt, alpha, dx, vol, K){
pu =  1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) -
((alpha*x*dt)/dx)
pd = 1/2*((vol^2*dt + alpha^2*(x^2)*dt^2)/dx^2) +
((alpha*x*dt)/dx)
pm = 1 - pu - pd
prob = list(pu = pu, pm = pm, pd = pd)
return(prob)
}
# transition probs
level_x2 = dx*seq(from = -2, to = 2, by = 1)
probs_level3 = prob(3, dt, alpha, dx, sigma)
# Calculate a_3 so we can get option values at j = 3
df = exp(-r*dt)
Q_2 = c(0.0252, 0.2199, 0.4998, 0.2199, 0.0252)
#Want Q_level3: will have 7 nodes.
Q_3 = numeric(length = nbNodes)
#according to "State prices continued" slide
prob2_1 = prob(level_x2[1], dt, alpha, dx, sigma)
prob2_2 = prob(level_x2[2], dt, alpha, dx, sigma)
prob2_3 = prob(level_x2[3], dt, alpha, dx, sigma)
prob2_4 = prob(level_x2[4], dt, alpha, dx, sigma)
prob2_5 = prob(level_x2[5], dt, alpha, dx, sigma)
P_2 = c(.1401, .6635, .1964, .1530, .6659, .1811,
.1667, .6667, .1667, .1811, .6659, .1530,
.1964, .1530, .6635, .1401)
Q_3[1] = Q_2[1]*P_2[1]*df
Q_3[nbNodes] = Q_3[1]
Q_3[2] = Q_2[1]*P_2[2]*df + Q_2[2]*P_2[4]*df
P_2
P_2[1]
nbNodes
Q_3[1] = Q_2[1]*P_2[1]*df
Q_2
df
df = exp(-r*dt)
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
S4_Params[]
S4_Params["R_ts",1]
df = exp(-S4_Params["R_ts",1]*dt)
Q_3[1] = Q_2[1]*P_2[1]*df
Q_3[nbNodes] = Q_3[1]
Q_3[2] = Q_2[1]*P_2[2]*df + Q_2[2]*P_2[4]*df
Q_3[nbNodes-1] = Q_3[2]
Q_3
Q_2
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
Q_3
