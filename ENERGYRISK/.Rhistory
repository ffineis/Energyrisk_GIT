t1 = i/nbDays
#standard normal random variables... get number between 0 and 1 and find value giving that quantile from normal dist.
rand1 = qnorm(runif(1,min=0,max=1)) #epsilon 1
rand2 = qnorm(runif(1,min=0,max=1)) #epsilon 2
dz1 = sqrt(dt)*rand1
# stochastic gas component which is correlated to power demand
dz2 = S6_ModelParams$rho[1]*dz1 + sqrt(1-(S6_ModelParams$rho[1])^2)*sqrt(dt)*rand2
# Estimate mu from mean-reverting model and forward prices?
muPower = (1/S6_ModelParams[1,"alpha"])*
(log(F_t2[1])-log(F_t1[1]))/(1/12) +
log(F_t1[1]) + S6_ModelParams[1,"sigma"]^2 /
(4*S6_ModelParams[1,"alpha"] ) *(1 - exp(-2*S6_ModelParams[1,"alpha"]*t1))
muGas = (1/S6_ModelParams[2,"alpha"])*
(log(F_t2[2])-log(F_t1[2]))/(1/12) +
log(F_t1[2]) + S6_ModelParams[2,"sigma"]^2 /
(4*S6_ModelParams[2,"alpha"] ) *(1 - exp(-2*S6_ModelParams[2,"alpha"]*t1))
# delta_x = (alpha(mu-x) - .5*sigma^2)*dt - sigma*sqrt(t)*epsilon
tempPower = log(valueStor[i,"Power"]) + (S6_ModelParams[1,"alpha"]*
(muPower-log(valueStor[i,"Power"])) -
0.5 * S6_ModelParams[1,"sigma"]^2) * dt + S6_ModelParams[1,"sigma"]* dz1
tempGas = log(valueStor[i,"Gas"]) + (S6_ModelParams[2,"alpha"]*
(muGas-log(valueStor[i,"Gas"])) -
0.5 * S6_ModelParams[2,"sigma"]^2) * dt + S6_ModelParams[2,"sigma"]* dz2
valueStor[i+1,"Power"] = exp(tempPower)
valueStor[i+1,"Gas"] = exp(tempGas)
# Option value payoff for plant: df*max(0, P-HR*G-K)
valueStor[i+1,"CT"] = max(0,valueStor[i+1,"Power"]-param$heatRate*valueStor[i+1,"Gas"]-
param$K)*
exp(-param$r*(as.numeric(storDates[i]-valDate)/365))#discount_factor
}
valDate = storDates[1]; valEnd = storDates[length(storDates)] #valuation dates
for(i in 1:(nbDays-1)){   #each simulation simulates 364 days
trackMonth = which(format(S6_ForwardCurve$Date,"%m%y")==format(storDates[i+1],"%m%y")) #keep track of month
#get current month and next month's forward prices
F_t1 = c(S6_ForwardCurve[trackMonth,"Power"],S6_ForwardCurve[trackMonth,"Gas"])
F_t2 = c(S6_ForwardCurve[trackMonth+1,"Power"],S6_ForwardCurve[trackMonth+1,"Gas"])
t1 = i/nbDays
#standard normal random variables... get number between 0 and 1 and find value giving that quantile from normal dist.
rand1 = qnorm(runif(1,min=0,max=1)) #epsilon 1
rand2 = qnorm(runif(1,min=0,max=1)) #epsilon 2
dz1 = sqrt(dt)*rand1
# stochastic gas component which is correlated to power demand
dz2 = S6_ModelParams$rho[1]*dz1 + sqrt(1-(S6_ModelParams$rho[1])^2)*sqrt(dt)*rand2
# Estimate mu from mean-reverting model and forward prices?
muPower = (1/S6_ModelParams[1,"alpha"])*
(log(F_t2[1])-log(F_t1[1]))/(1/12) +
log(F_t1[1]) + S6_ModelParams[1,"sigma"]^2 /
(4*S6_ModelParams[1,"alpha"] ) *(1 - exp(-2*S6_ModelParams[1,"alpha"]*t1))
muGas = (1/S6_ModelParams[2,"alpha"])*
(log(F_t2[2])-log(F_t1[2]))/(1/12) +
log(F_t1[2]) + S6_ModelParams[2,"sigma"]^2 /
(4*S6_ModelParams[2,"alpha"] ) *(1 - exp(-2*S6_ModelParams[2,"alpha"]*t1))
# delta_x = (alpha(mu-x) - .5*sigma^2)*dt - sigma*sqrt(t)*epsilon
tempPower = log(valueStor[i,"Power"]) + (S6_ModelParams[1,"alpha"]*
(muPower-log(valueStor[i,"Power"])) -
0.5 * S6_ModelParams[1,"sigma"]^2) * dt + S6_ModelParams[1,"sigma"]* dz1
tempGas = log(valueStor[i,"Gas"]) + (S6_ModelParams[2,"alpha"]*
(muGas-log(valueStor[i,"Gas"])) -
0.5 * S6_ModelParams[2,"sigma"]^2) * dt + S6_ModelParams[2,"sigma"]* dz2
valueStor[i+1,"Power"] = exp(tempPower)
valueStor[i+1,"Gas"] = exp(tempGas)
# Option value payoff for plant: df*max(0, P-HR*G-K)
valueStor[i+1,"CT"] = max(0,valueStor[i+1,"Power"]-param$heatRate*valueStor[i+1,"Gas"]-
param$K)*
exp(-param$r*(as.numeric(storDates[i]-valDate)/365))#discount_factor
}
valueStor
sum(valueStor[,3])
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/Demo6_code.R')
simStor
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
se = sd(simStor[,"Thermal_valuation"])/sqrt(param$M)
se
mean(simStor[,"Thermal_valuation"])
colnames(simStor) = c("MC_iteration", "Thermal_valuation")
se = sd(simStor[,"Thermal_valuation"])/sqrt(param$M) #standard error in MC valuation
thermal_val = mean(simStor[,"Thermal_valuation"])
result = data.frame(t(c(thermal_val, se)))
colnames(result) = c("Call_value", "std_error")
rownames(result) = "Result"
result
avgOptionValue = matrix(0, param$M, 1)
for (kk in 1:param$M){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
head(simStor)
avgOptionValue = matrix(0, param$M, 1)
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
avgOptionValue
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
S6_ForwardCurve
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8,
main = "Monte Carlo Convergence of Option Value") #we haven't implemented antithetic valuation method.
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value")
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value")
title("Monte Carlo Convergence of Option Value", cex = .8)
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value", cex = .8)
title("Monte Carlo Convergence of Option Value", cex.main = .8)
#Plotting valuation progression:
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations")
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
title("Monte Carlo Convergence of Option Value", cex.main = .8)
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
#Distribution of MC payoffs
hist(simMatrix[,2],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStore[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",N,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"))
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 20)
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 200)
hist(simStor[,"Thermal_valuation"],xlab="Payoff Bin",main=paste("Frequency of",param$M,"Simulations"), breaks = 20)
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
abline(h = result$Call_value, col = "red")
source('~/.active-rstudio-document')
avgOptionValue = matrix(0, param$M, 1) #store cumulative mean payoff
for (kk in simStor[,"MC_iteration"]){avgOptionValue[kk] = mean(simStor[1:kk,"Thermal_valuation"])}
plot(c(avgOptionValue),type="l", ylab="Payoff", xlab="Number of Simulations", main = "Monte Carlo Convergence of Option Value", cex.main = .9)
legend("topright",legend=c("Simple Method"),col = c(1), lwd=c(1.5), lty=c(1), cex=0.8) #we haven't implemented antithetic valuation method.
abline(h = result$Call_value, col = "red")
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
### CFRM 520 HW2. Frank Fineis.
library(ENERGYRISK)
source("./R/Lattices.R")
data(S4_Params)
tree_Params <- list("alpha" = 0.338, "delta_t" = 0.08333333, "delta_x" = 0.152702,
"S0" = 21.05, "K" = 21, "maturity" = 1, "r" = 0.06, "volatility" = 0.305404)
a_is <- t(data.frame(c(3.046901, 3.041576, 3.034532, 3.027756, 3.021138, 3.014664, 3.008326)))
colnames(a_is) <- c("X0", "X1", "X2", "X3", "X4", "X5", "X6")
rownames(a_is) <- "a_i"
#set up tree characteristics for the preliminary tree.
discount <- exp(-tree_Params$r*tree_Params$delta_t)
level_x = -c(-tree_Params$delta_x*((6):1),tree_Params$delta_x*(0:(6))) #trinomial tree prices at time N/2. Symmetric about 0.
j.index = seq(from=0, to=6, by=1) #month number, 0 to 6 by 1's
nbNodes = seq(from=1,to=length(level_x),by=2) #number of nodes at each time point
##### Value EUROPEAN PUT Option ####
mult = -1 #put option...
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("European Put Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Primary difference between EUROPEAN and AMERICAN Options
# Update the V vector of option values at each time step and node
V = pmax(0, discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("European Put Values:\n")
print(V)
offset = offset +1
}
##### Value AMERICAN CALL Option ####
mult = 1 #call, not put. Put is valued at K-S.
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
any(Forw<16)
any(Forw>30)
KOed = which(Forw>30 | Forw<16)
Koed
KOed
tree_Params$K
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
KOed = which(Forw>30 | Forw<16)
Forw[KOed] <- 0
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
##### Value AMERICAN PUT Double Barrier Knock-out Option ####
mult = -1 #call, not put. Put is valued at K-S.
barrier = c(16, 30)
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
KOed = which(Forw<barrier[1] | Forw>barrier[2])
Forw[KOed] <- 0
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
KOed = which(Forw<barrier[1] | Forw>barrier[2])
Forw[KOed] <- 0
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# Print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
##### Value AMERICAN CALL Option ####
mult = 1 #call, not put. Put is valued at K-S.
# i) Fitted forward prices, spot price data fitted correctly
Forw = exp(as.numeric(a_is[length(j.index)]) + level_x)
V = pmax(0, mult * (Forw- tree_Params$K))
# forward prices and option values at time = 0.5 yr
cat("Time step: ", 6, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
i.index = seq(from=6-1, to=0, by=-1)
offset = 1
# backward induction steps:
for (i in i.index) {
# moving backwards, get spot prices on preliminary tree at previous time
level_xt = -c(-tree_Params$delta_x*((i):1),tree_Params$delta_x*(0:i))
# Get transition probabilities to estimate expected value
j  = level_xt
#print(sprintf("level_xt: %s", level_xt))
prob = prob(j, tree_Params$delta_t, tree_Params$alpha, tree_Params$delta_x, tree_Params$volatility)
# Sub bind the expectation values together
E_V = cbind(V[1:(length(V)-2)],V[2:(length(V)-1)],V[3:length(V)])
# F is the vector of prices at each time step and node
Forw = exp(as.numeric(a_is[length(j.index)-offset]) + level_xt)
# Now value is either exercising option or EV of not exercising
V = pmax(mult*(Forw-tree_Params$K), discount * diag(E_V%*%prob))
if (i==0){Forw = Forw[1]; V= V[1]}
# The following print out is useful for a trinomial function
# It will print out the results as the function is running to keep track
cat("Time step: ", i, "\n", sep="")
cat("Prices:\n")
print(Forw)
cat("American Call Values:\n")
print(V)
offset = offset +1
}
source('~/Desktop/AMATH_Summer_UW/CFRM_520/EnergyRisk/Energyrisk_GIT/ENERGYRISK/homework_files/HW2.R')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
library(ENERGYRISK)
24*365
source('~/.active-rstudio-document')
data(data_S7)
View(`S7_ModelParams`)
S7_ModelParams
head(S7_ModelParams)
source('~/.active-rstudio-document')
valDate
class(valDate)
storDates = as.Date(valDate:valEnd)
library(lubridate)
library(zoo)
data(data_S7)
#get model parameters to project Power and rainfall evolution
head(S7_ModelParams)
N = 100 # number of simulations
valDate = as.Date("01/01/09", format = "%m/%d/%y")
valEnd = as.Date("03/31/09", format = "%m/%d/%y")
storDates = as.Date(valDate:valEnd)
class(storDates)
storWkday = as.POSIXlt(storDates, format = "%Y-%m-%d")
storWkday
nbDays = as.numeric(valEnd-valDate)
length(storDates)
Efficiency = 0.7222 # 72.22% of energy used to pump water up will be regained
F_Peak = 55; F_OPeak = 25; r = 0.05
param = list(Efficiency = Efficiency, F_Peak = F_Peak, F_OPeak = 25, r = r, N = N)
param
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
simMatrix = matrix(0, param$N, 2)
dt = 1/(365*2*24)
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
nb30min = nbDays*24*2 #number of 30-min intervals in day
valueStor = matrix(0, nb30min, 7)
colnames(valueStor) = c("Period", "Power", "PumpGen", "PumpingCost", "GenRevenue", "volPumped", "CT")
simMatrix = matrix(0, param$N, 2)
dt = 1/(365*2*24)
rep(1:48, nb30min/48)
nb30min
storDates[1]
storDates[3]
storDates[2]
storWkday
storWkday[1]
storWkday[3]
storWkday[3]==3
storWkday[3]==2
storWkday[3]==1
storWkday[3]==4
storWkday[3]==5
storWkday[3]==6
storWkday[3]==7
storWkday = storWkday$wday
storWkday[3]==6
storWkday[3]==5
source("./R/ENERGYRISK.R")
source("./R/ES1_F.R")
S7_ModelParams$jFrequency
S7_ModelParams$jFrequency[1]
S7_ModelParams
S7_ModelParams$jFrequency[1]*dt
dt
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
as.numeric(TRUE)
as.numeric(FALSE)
S7_ModelParams$jFrequency[1]*dt
i - 3
i = 3
valueStor[,"Period"] = rep(1:48, nb30min/48)
valueStor[1,"Power"] = param$F_OPeak
F_t1 = param$F_OPeak ##### IMPORTANT ######
valueStor[1, "PumpGen"] = -1 #offpeak
offsetDate = 1
offset = -48 #index for new day
trackDate = 1
if(valueStor[i, "Period"] == 1){offset = offset+48} #indexing can't start at -48
if(storDates[offsetDate]=="2009-01-01"){muPower=param$F_OPeak}
else if(storWkday[trackDate]==6||storWkday[trackDate]==0){muPower=param$F_OPeak}
else if(valueStor[i,"Period"]>44||valueStor[i,"Period"]<15){muPower=param$F_OPeak}
else{muPower=param$F_Peak}
F_t2 = muPower
t1=i/(365*2*24)
rand1=randPolarRejc()
rand2=randPolarRejc()
dz1 = sqrt(dt)*rand1
dz2 = sqrt(dt)*rand2
#TRUE = 1, FALSE = 0
jFrequency = as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
#get mu from model:
muPower = (1/S7_ModelParams$alpha[1])*(log(F_t2)-log(F_t1))/dt + log(F_t1) + S7_ModelParams$sigma[1]^2/(4*S7_ModelParams$alpha[1])*(1-exp(-2*S7_ModelParams$alpha[1]*t1))
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
muPower
dz2
dz1
t1
muPower
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
head(valueStor)
i = 1
if(valueStor[i, "Period"] == 1){offset = offset+48} #indexing can't start at -48
if(storDates[offsetDate]=="2009-01-01"){muPower=param$F_OPeak}
else if(storWkday[trackDate]==6||storWkday[trackDate]==0){muPower=param$F_OPeak}
else if(valueStor[i,"Period"]>44||valueStor[i,"Period"]<15){muPower=param$F_OPeak}
else{muPower=param$F_Peak}
F_t2 = muPower
t1=i/(365*2*24)
rand1=randPolarRejc()
rand2=randPolarRejc()
dz1 = sqrt(dt)*rand1
dz2 = sqrt(dt)*rand2
#TRUE = 1, FALSE = 0
jFrequency = as.numeric(S7_ModelParams$jFrequency[1]*dt < qnorm(runif(1,min = 0 ,max = 1)))
#get mu from model:
muPower = (1/S7_ModelParams$alpha[1])*(log(F_t2)-log(F_t1))/dt + log(F_t1) + S7_ModelParams$sigma[1]^2/(4*S7_ModelParams$alpha[1])*(1-exp(-2*S7_ModelParams$alpha[1]*t1))
tempPower = log(valueStor[i,"Power"])+(S7_ModelParams[1,"alpha"]*(muPower-log(valueStor[i,"Power"]))-0.5*S7_ModelParams[1,"sigma"]^2)*dt + S7_ModelParams[1,"sigma"]* dz1 +
jFrequency*S7_ModelParams[1,"volJump"]* dz2
tempPower
45*30
48*30
offset
jFrequency
